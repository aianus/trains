\documentclass{article}

\title{CS 452 Kernel 2 Documentation}
\author{
  Avi Itskovich, 20332164
  \and
  Alex Ianus, 20342535
}

\begin{document}

\maketitle

\section{Overview}

This documentation covers the implementation of the Kernel for Assignment 3. This assignment covered AwaitEvent and the ClockServer. The new system calls are: 
\begin{itemize}
  \item int AwaitEvent(int eventid)
\end{itemize}
The ClockServer has the following interface:
\begin{itemize}
  \item int Delay(int ticks)
  \item int Time()
  \item int DelayUntil(int ticks)
\end{itemize}

\section{Operating Instructions}
\begin{enumerate}
  \item load -b 0x00218000 -h 10.15.167.4 \$executable
  \item go
\end{enumerate}

\section{Submitted Files}
Root directory: /u1/aianus/handin/kernel3/

\subsection{Executable}
56b3fd7399843384a7c0bc4cd208076a  /kernel3.elf
\subsection{Code}

\section{Kernel Description}

\subsection{Interrupts}

Our interrupt system can be divided into two parts: handling interrupts as they occur and managing them (enable/disable) and bubbling up events to the system.

\subsubsection{Interrupt Handling}

Interrupt handling is all done through a simple set of primitives available in "interrupt.c". These primitives allow you to enable, disable, generate and clear a specific interrupt. Interrupts are defined in an enum and as we have more interesting interrupts we add them to the enum.

\subsubsection{Event Management}

\subsection{Context Switch}

For this assignment we re-wrote a majority of our context switch code for simplification. Although, our old code was perfectly useful for hardware interrupts, we wanted to speed up our context switch and make it easier to read.

\subsection{Hardware Interrupt}

Our Hardware Interrupt context switch is implemented through a wrapping mechanism. We introduce a new entry point, irq\_enter, which saves the scratch registers on the user's stack before jumping (bl) into our regular mechanism of entering the kernel (kernel\_enter). By using bl to jump into kernel\_enter, we modify the link register so when kernel\_exit completed if you entered kernel\_enter through the irq handler, you come back to it so we can unwrap the scratch registers.

\subsubsection{irq\_enter:}
\begin{enumerate}
    \item Change to System Mode.
    \item Save scratch registers onto user stack (r0, r1, r2, r3, ip).
    \item Change to IRQ Mode.
    \item Grab LR/SPSR.
    \item Change to System Mode. 
    \item Save LR/SPSR onto user stack.
    \item Change to Supervisor Mode.
    \item Insert special value (0) into r0 to represent irq interrupt.
    \item Change our supervisor\_spsr to IRQ Mode.
    \item Jump into Kernel Enter.
\end{enumerate}

\subsubsection{irq\_exit:}
\begin{enumerate}
    \item Switch to System Mode.
    \item Unload LR/SPSR.
    \item Switch to Interrupt Mode.
    \item Install LR/SPSR.
    \item Switch to System Mode.
    \item Reload Scratch Registers (r0, r1, r2, r3, ip)
    \item Switch to IRQ Mode
    \item Jump back into program and install correct cpsr.
\end{enumerate}

Note that irq\_exit does not exist as a label, and is simply a convention to refer to the lines after "bl kernel\_enter".

\subsection{Software Interrupt}

During the implementation of this assignment we decided to overhaul our basic context switch as well. Previously, we stored a lot of data in the Task Descriptor. We have now moved almost all of this data into the user stack. The only information we maintain in the task descriptor is the stack pointer itself. Our new kernel\_enter and kernel\_exit function as follows:

\subsubsection{kernel\_exit:}
\begin{enumerate}
    \item Save Kernel State (including r0 since it contains our task descriptor memory location).
    \item Load the SP for task from it's task descriptor.
    \item Change to System Mode. 
    \item Install Stack Pointer.
    \item Unload User Registers + PC/SPSR from User Stack.
    \item Change to Supervisor Mode.
    \item Install SPSR
    \item Jump to user PC and install correct cpsr.
\end{enumerate}

\subsubsection{kernel\_enter:}
\begin{enumerate}
   \item Save SPSR/Link Register into Common Registers.
   \item Change to System State.
   \item Save User State + SPSR/Link Register on Stack.
   \item Grab User SP in Common Register.
   \item Change to Supervisor State.
   \item Backup Request in Scratch Register.
   \item Load Kernel State.
   \item Store User's SP into Task Descriptor (memory address is in r0).
   \item Install the backed up Request in r0.
   \item Jump into the Kernel.
\end{enumerate}

\subsubsection{Idle Task}

\subsection{Clock Server}

\subsubsection{Server}
The clock server, running at priority HIGHEST, is implemented as an infinite message handling loop. 

On a tick message, the internal time of the clock server is incremented by one. Furthermore, any tasks on top of the priority queue whose deadline has passed are unblocked with a Reply.

On a delay message, the sending task is placed in the priority queue with priority equal to the deadline which is equal to the current time + the specified delay.

On a delay_until message, the deadline is compared to the current time and if it has not yet passed the task is placed on the priority queue with priority equal to the deadline. If the deadline has already passed, the task is not placed on the queue but is immediately unblocked with a Reply.

On a time message, a reply is immediately issued with the current time in ticks.

The priority queue is implemented as a heap so that the most frequent operation, checking the deadline of the head of the queue, is done in very fast constant time. Furthermore, popping and pushing tasks from/onto the queue is also very fast, running in O(logn) time. In addition, the heap is implemented as an array, which should give good cache performance as all the elements are in contiguous memory.

\subsubsection{Notifier}

\subsection{Output and Analysis}
\begin{verbatim}
Delay number 1 completed for task 4 having delay interval 10
Delay number 2 completed for task 4 having delay interval 10
Delay number 1 completed for task 5 having delay interval 23
Delay number 3 completed for task 4 having delay interval 10
Delay number 1 completed for task 6 having delay interval 33
Delay number 4 completed for task 4 having delay interval 10
Delay number 2 completed for task 5 having delay interval 23
Delay number 5 completed for task 4 having delay interval 10
Delay number 6 completed for task 4 having delay interval 10
Delay number 2 completed for task 6 having delay interval 33
Delay number 3 completed for task 5 having delay interval 23
Delay number 1 completed for task 7 having delay interval 71
Delay number 7 completed for task 4 having delay interval 10
Delay number 8 completed for task 4 having delay interval 10
Delay number 4 completed for task 5 having delay interval 23
Delay number 9 completed for task 4 having delay interval 10
Delay number 3 completed for task 6 having delay interval 33
Delay number 10 completed for task 4 having delay interval 10
Delay number 5 completed for task 5 having delay interval 23
Delay number 11 completed for task 4 having delay interval 10
Delay number 12 completed for task 4 having delay interval 10
Delay number 4 completed for task 6 having delay interval 33
Delay number 13 completed for task 4 having delay interval 10
Delay number 6 completed for task 5 having delay interval 23
Delay number 2 completed for task 7 having delay interval 71
Delay number 14 completed for task 4 having delay interval 10
Delay number 15 completed for task 4 having delay interval 10
Delay number 7 completed for task 5 having delay interval 23
Delay number 5 completed for task 6 having delay interval 33
Delay number 16 completed for task 4 having delay interval 10
Delay number 17 completed for task 4 having delay interval 10
Delay number 8 completed for task 5 having delay interval 23
Delay number 18 completed for task 4 having delay interval 10
Delay number 6 completed for task 6 having delay interval 33
Delay number 19 completed for task 4 having delay interval 10
Delay number 9 completed for task 5 having delay interval 23
Delay number 3 completed for task 7 having delay interval 71
Delay number 20 completed for task 4 having delay interval 10
\end{verbatim}

If we map each line to the delay number * the delay interval we see a sequence that is almost strictly increasing, with a few exceptions (such as Delay #1 for task 7 with interval 71 occurring before Delay #7 for task 4 with interval 10).  We speculate this drift is caused by the time it takes the task to print its status message after each delay. This is a known pitfall in using Delay repeatedly instead of using DelayUntil which would allow us to measure and bound the drift. 

\subsection{Known Bugs and Limitations}


\end{document}
