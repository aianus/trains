\documentclass{article}

\title{CS 452 Project 2 Documentation}
\author{
  Avi Itskovich, 20332164
  \and
  Alex Ianus, 20342535
}

\begin{document}

\maketitle

\section{Overview}

This documentation covers milestone one of our train project.

\section{Operating Instructions}
\begin{enumerate}
  \item Reset the box and wait for the redboot prompt
  \item load -b 0x00218000 -h 10.15.167.4 \$executable
  \item go
\end{enumerate}

\section{Submitted Files}
Root directory: /u1/aianus/cs452/handin/project1/

\subsection{Executable}
\begin{verbatim}
e901cd3cd93b0dd7973a1ee99c73b7c2  ./project1.elf
\end{verbatim}

\subsection{Code}
\begin{verbatim}
\end{verbatim}

\section{User Program Description}

\subsection{PubSub System}

Since we use a publish-subscribe model in our system, we made a generalizable system to allow any server to support this. Previously, each server implemented PubSub by itself, and only had one courier for subscriptions. Our new system has 3 different couriers which at different priorities. These allow a low priority task like the train\_widget to subscribe to the same stream as the train controller without a performance loss. Our pubsub sustem supports the following API:

\begin{itemize}
  \item int CreateStream(char *name) - Creates the set of tasks and returns the tid of the PubSub server it created. The name is assigned to the PubSub server in the NameServer.
  \item void Subscribe(char *name, int priority) - Subscribe to a stream. You will begin recieving updates after calling this.
  \item void Unsubscribe(char *name, int priority) - Unsubscribe from a stream. You will recieve no more updates after calling this,
  \item void Publish(tid\_t stream, Message msg) - Publish a message to a stream. This message gets forwarded to all subscribers of the stream. Ordering of messages is guaranteed as fifo.
\end{itemize}

This lets us clearly seperate different components of the system and allow them to communicate through streams. It also allows us to easily introspect these streams so we can show the data on the screen.

\subsection{Calibration}

For this milestone we re-calibrated our trains. We created a calibration program for calibrating the average speed of the train. This program calibrates speeds from 2 - 14, by averaging speeds measured over multiple sensor hits. We also generated new acceleration models for the trains. These were generated using the assumption of quadratic acceleration. We measured how long it took the train to accelerate in ticks and using that along with it's velocity at that speed to generate the quadratic acceleration. We also did some manual tweaking of this, waiting a couple of ticks before using this function to better map the train.

\subsection{Sensor Attribution}

Sensor attribution now supports multiple trains. Each train maintains a list of pending sensors that it is expecting to hit. A hit of a sensor that is not associated with any train is considered a spurious hit. Two trains may be waiting for the same sensor. We solve this conflict by giving the sensor to the train with the highest velocity. This isn't a good solution. However, it fixes the issue of having the trains start up at the same siding. A better solution would be to use the train's distance along an edge for this. We just haven't gotten around to implementing it yet.

Internally we augment this distance along an edge every tick based on a trains current velocity. Once we have reached the end of an edge we switch to the next one. If the source of next edge is a sensor, we try to wait for a sensor to fire before switching to that edge. We will wait up to 10cm of extra distance before switching to that edge. If we do switch to that edge, we will record a missed sensor. During sensor attribution this is also checked before a sensor hit is deemed spurious. If we are going to miss a second sensor, we do not switch edges again. This is necessary, because otherwise a stall can cause us to think we're just missing all sensors in a path instead of actually being stalled.

\subsection{Switch Failure}

Switch failure is handled by having each train have as it's pending sensors all sensors down both sides of the branch. This way if we trip either of them we will know where we are. This seems to work quite well in practice. However, it's useless in places where one branch has no sensors.

\subsection{Shell Augmentation}

We've added some simple augmentations to our shell system:
\begin{itemize}
  \item The go command now accepts multiple train/destination pairs.
  \item We've added an orient command so we can the train which direction it is facing.
  \item We've added a calibrate command to facilitate train calibration.
\end{itemize}

\subsection{Train Widget}

During working on this demo we realized our train widget was printing much too often. We instead moving to a differential model, where we only print what's changed. However, this still wasn't enough becuase things were changing too quickly. So we further expanded on that to have it only print what changed every 10 ticks

\subsection{Reservation System}

\subsection{Pathfinding}

\subsection{Known Bugs and Limitations}
\begin{itemize}
  \item There are cases where trains estimated positions can cross over each other, even with the reservation system in place.
  \item Trains on the same edge may get confused by a sensor firing, confusing which train it goes to. However, this issue is heavily mitigated by the reservation system, which does not allow two trains on the same edge.
\end{itemize}

\end{document}
